// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: mes.ud.proto

#ifndef PROTOBUF_mes_2eud_2eproto__INCLUDED
#define PROTOBUF_mes_2eud_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "mes.base.pb.h"
// @@protoc_insertion_point(includes)

namespace message {

// Internal implementation detail -- do not call these.
    void protobuf_AddDesc_mes_2eud_2eproto();

    void protobuf_AssignDesc_mes_2eud_2eproto();

    void protobuf_ShutdownFile_mes_2eud_2eproto();

    class task;

    class task_job;

    class status;

    enum task_type {
        task_type_calculate = 0,
        task_type_file_transfer = 1,
        task_type_terminate = 2
    };

    bool task_type_IsValid(int value);

    const task_type task_type_type_MIN = task_type_calculate;
    const task_type task_type_type_MAX = task_type_terminate;
    const int task_type_type_ARRAYSIZE = task_type_type_MAX + 1;

    const ::google::protobuf::EnumDescriptor *task_type_descriptor();

    inline const ::std::string &task_type_Name(task_type value) {
        return ::google::protobuf::internal::NameOfEnum(
                task_type_descriptor(), value);
    }

    inline bool task_type_Parse(
            const ::std::string &name, task_type *value) {
        return ::google::protobuf::internal::ParseNamedEnum<task_type>(
                task_type_descriptor(), name, value);
    }
// ===================================================================

    class task_job : public ::google::protobuf::Message {
    public:
        task_job();

        virtual ~task_job();

        task_job(const task_job &from);

        inline task_job &operator=(const task_job &from) {
            CopyFrom(from);
            return *this;
        }

        inline const ::google::protobuf::UnknownFieldSet &unknown_fields() const {
            return _unknown_fields_;
        }

        inline ::google::protobuf::UnknownFieldSet *mutable_unknown_fields() {
            return &_unknown_fields_;
        }

        static const ::google::protobuf::Descriptor *descriptor();

        static const task_job &default_instance();

        void Swap(task_job *other);

        // implements Message ----------------------------------------------

        task_job *New() const;

        void CopyFrom(const ::google::protobuf::Message &from);

        void MergeFrom(const ::google::protobuf::Message &from);

        void CopyFrom(const task_job &from);

        void MergeFrom(const task_job &from);

        void Clear();

        bool IsInitialized() const;

        int ByteSize() const;

        bool MergePartialFromCodedStream(
                ::google::protobuf::io::CodedInputStream *input);

        void SerializeWithCachedSizes(
                ::google::protobuf::io::CodedOutputStream *output) const;

        ::google::protobuf::uint8 *SerializeWithCachedSizesToArray(::google::protobuf::uint8 *output) const;

        int GetCachedSize() const { return _cached_size_; }

    private:
        void SharedCtor();

        void SharedDtor();

        void SetCachedSize(int size) const;

    public:
        ::google::protobuf::Metadata GetMetadata() const;

        // nested types ----------------------------------------------------

        // accessors -------------------------------------------------------

        // required .message.task.type job_type = 1;
        inline bool has_job_type() const;

        inline void clear_job_type();

        static const int kJobTypeFieldNumber = 1;

        inline ::message::task_type job_type() const;

        inline void set_job_type(::message::task_type value);

        // optional string file_path = 2;
        inline bool has_file_path() const;

        inline void clear_file_path();

        static const int kFilePathFieldNumber = 2;

        inline const ::std::string &file_path() const;

        inline void set_file_path(const ::std::string &value);

        inline void set_file_path(const char *value);

        inline void set_file_path(const char *value, size_t size);

        inline ::std::string *mutable_file_path();

        inline ::std::string *release_file_path();

        inline void set_allocated_file_path(::std::string *file_path);

        // optional string description = 3;
        inline bool has_description() const;

        inline void clear_description();

        static const int kDescriptionFieldNumber = 3;

        inline const ::std::string &description() const;

        inline void set_description(const ::std::string &value);

        inline void set_description(const char *value);

        inline void set_description(const char *value, size_t size);

        inline ::std::string *mutable_description();

        inline ::std::string *release_description();

        inline void set_allocated_description(::std::string *description);

        // @@protoc_insertion_point(class_scope:message.task.job)
    private:
        inline void set_has_job_type();

        inline void clear_has_job_type();

        inline void set_has_file_path();

        inline void clear_has_file_path();

        inline void set_has_description();

        inline void clear_has_description();

        ::google::protobuf::UnknownFieldSet _unknown_fields_;

        ::google::protobuf::uint32 _has_bits_[1];
        mutable int _cached_size_;
        ::std::string *file_path_;
        ::std::string *description_;
        int job_type_;

        friend void protobuf_AddDesc_mes_2eud_2eproto();

        friend void protobuf_AssignDesc_mes_2eud_2eproto();

        friend void protobuf_ShutdownFile_mes_2eud_2eproto();

        void InitAsDefaultInstance();

        static task_job *default_instance_;
    };
// -------------------------------------------------------------------

    class task : public ::google::protobuf::Message {
    public:
        task();

        virtual ~task();

        task(const task &from);

        inline task &operator=(const task &from) {
            CopyFrom(from);
            return *this;
        }

        inline const ::google::protobuf::UnknownFieldSet &unknown_fields() const {
            return _unknown_fields_;
        }

        inline ::google::protobuf::UnknownFieldSet *mutable_unknown_fields() {
            return &_unknown_fields_;
        }

        static const ::google::protobuf::Descriptor *descriptor();

        static const task &default_instance();

        void Swap(task *other);

        // implements Message ----------------------------------------------

        task *New() const;

        void CopyFrom(const ::google::protobuf::Message &from);

        void MergeFrom(const ::google::protobuf::Message &from);

        void CopyFrom(const task &from);

        void MergeFrom(const task &from);

        void Clear();

        bool IsInitialized() const;

        int ByteSize() const;

        bool MergePartialFromCodedStream(
                ::google::protobuf::io::CodedInputStream *input);

        void SerializeWithCachedSizes(
                ::google::protobuf::io::CodedOutputStream *output) const;

        ::google::protobuf::uint8 *SerializeWithCachedSizesToArray(::google::protobuf::uint8 *output) const;

        int GetCachedSize() const { return _cached_size_; }

    private:
        void SharedCtor();

        void SharedDtor();

        void SetCachedSize(int size) const;

    public:
        ::google::protobuf::Metadata GetMetadata() const;

        // nested types ----------------------------------------------------

        typedef task_job job;

        typedef task_type type;
        static const type calculate = task_type_calculate;
        static const type file_transfer = task_type_file_transfer;
        static const type terminate = task_type_terminate;

        static inline bool type_IsValid(int value) {
            return task_type_IsValid(value);
        }

        static const type type_MIN =
                task_type_type_MIN;
        static const type type_MAX =
                task_type_type_MAX;
        static const int type_ARRAYSIZE =
                task_type_type_ARRAYSIZE;

        static inline const ::google::protobuf::EnumDescriptor *
        type_descriptor() {
            return task_type_descriptor();
        }

        static inline const ::std::string &type_Name(type value) {
            return task_type_Name(value);
        }

        static inline bool type_Parse(const ::std::string &name,
                                      type *value) {
            return task_type_Parse(name, value);
        }

        // accessors -------------------------------------------------------

        // required .message.tcp_id tcp_id = 1;
        inline bool has_tcp_id() const;

        inline void clear_tcp_id();

        static const int kTcpIdFieldNumber = 1;

        inline const ::message::tcp_id &tcp_id() const;

        inline ::message::tcp_id *mutable_tcp_id();

        inline ::message::tcp_id *release_tcp_id();

        inline void set_allocated_tcp_id(::message::tcp_id *tcp_id);

        // required int32 task_id = 2;
        inline bool has_task_id() const;

        inline void clear_task_id();

        static const int kTaskIdFieldNumber = 2;

        inline ::google::protobuf::int32 task_id() const;

        inline void set_task_id(::google::protobuf::int32 value);

        // repeated .message.task.job jobs = 3;
        inline int jobs_size() const;

        inline void clear_jobs();

        static const int kJobsFieldNumber = 3;

        inline const ::message::task_job &jobs(int index) const;

        inline ::message::task_job *mutable_jobs(int index);

        inline ::message::task_job *add_jobs();

        inline const ::google::protobuf::RepeatedPtrField<::message::task_job> &
        jobs() const;

        inline ::google::protobuf::RepeatedPtrField<::message::task_job> *
        mutable_jobs();

        // optional .message.timestamp last_updated = 4;
        inline bool has_last_updated() const;

        inline void clear_last_updated();

        static const int kLastUpdatedFieldNumber = 4;

        inline const ::message::timestamp &last_updated() const;

        inline ::message::timestamp *mutable_last_updated();

        inline ::message::timestamp *release_last_updated();

        inline void set_allocated_last_updated(::message::timestamp *last_updated);

        // @@protoc_insertion_point(class_scope:message.task)
    private:
        inline void set_has_tcp_id();

        inline void clear_has_tcp_id();

        inline void set_has_task_id();

        inline void clear_has_task_id();

        inline void set_has_last_updated();

        inline void clear_has_last_updated();

        ::google::protobuf::UnknownFieldSet _unknown_fields_;

        ::google::protobuf::uint32 _has_bits_[1];
        mutable int _cached_size_;
        ::message::tcp_id *tcp_id_;
        ::google::protobuf::RepeatedPtrField<::message::task_job> jobs_;
        ::message::timestamp *last_updated_;
        ::google::protobuf::int32 task_id_;

        friend void protobuf_AddDesc_mes_2eud_2eproto();

        friend void protobuf_AssignDesc_mes_2eud_2eproto();

        friend void protobuf_ShutdownFile_mes_2eud_2eproto();

        void InitAsDefaultInstance();

        static task *default_instance_;
    };
// -------------------------------------------------------------------

    class status : public ::google::protobuf::Message {
    public:
        status();

        virtual ~status();

        status(const status &from);

        inline status &operator=(const status &from) {
            CopyFrom(from);
            return *this;
        }

        inline const ::google::protobuf::UnknownFieldSet &unknown_fields() const {
            return _unknown_fields_;
        }

        inline ::google::protobuf::UnknownFieldSet *mutable_unknown_fields() {
            return &_unknown_fields_;
        }

        static const ::google::protobuf::Descriptor *descriptor();

        static const status &default_instance();

        void Swap(status *other);

        // implements Message ----------------------------------------------

        status *New() const;

        void CopyFrom(const ::google::protobuf::Message &from);

        void MergeFrom(const ::google::protobuf::Message &from);

        void CopyFrom(const status &from);

        void MergeFrom(const status &from);

        void Clear();

        bool IsInitialized() const;

        int ByteSize() const;

        bool MergePartialFromCodedStream(
                ::google::protobuf::io::CodedInputStream *input);

        void SerializeWithCachedSizes(
                ::google::protobuf::io::CodedOutputStream *output) const;

        ::google::protobuf::uint8 *SerializeWithCachedSizesToArray(::google::protobuf::uint8 *output) const;

        int GetCachedSize() const { return _cached_size_; }

    private:
        void SharedCtor();

        void SharedDtor();

        void SetCachedSize(int size) const;

    public:
        ::google::protobuf::Metadata GetMetadata() const;

        // nested types ----------------------------------------------------

        // accessors -------------------------------------------------------

        // required .message.tcp_id tcp_id = 1;
        inline bool has_tcp_id() const;

        inline void clear_tcp_id();

        static const int kTcpIdFieldNumber = 1;

        inline const ::message::tcp_id &tcp_id() const;

        inline ::message::tcp_id *mutable_tcp_id();

        inline ::message::tcp_id *release_tcp_id();

        inline void set_allocated_tcp_id(::message::tcp_id *tcp_id);

        // required int32 task_id = 2;
        inline bool has_task_id() const;

        inline void clear_task_id();

        static const int kTaskIdFieldNumber = 2;

        inline ::google::protobuf::int32 task_id() const;

        inline void set_task_id(::google::protobuf::int32 value);

        // optional string description = 3;
        inline bool has_description() const;

        inline void clear_description();

        static const int kDescriptionFieldNumber = 3;

        inline const ::std::string &description() const;

        inline void set_description(const ::std::string &value);

        inline void set_description(const char *value);

        inline void set_description(const char *value, size_t size);

        inline ::std::string *mutable_description();

        inline ::std::string *release_description();

        inline void set_allocated_description(::std::string *description);

        // optional int32 percentage = 4;
        inline bool has_percentage() const;

        inline void clear_percentage();

        static const int kPercentageFieldNumber = 4;

        inline ::google::protobuf::int32 percentage() const;

        inline void set_percentage(::google::protobuf::int32 value);

        // optional string buffer = 5;
        inline bool has_buffer() const;

        inline void clear_buffer();

        static const int kBufferFieldNumber = 5;

        inline const ::std::string &buffer() const;

        inline void set_buffer(const ::std::string &value);

        inline void set_buffer(const char *value);

        inline void set_buffer(const char *value, size_t size);

        inline ::std::string *mutable_buffer();

        inline ::std::string *release_buffer();

        inline void set_allocated_buffer(::std::string *buffer);

        // required .message.timestamp last_updated = 6;
        inline bool has_last_updated() const;

        inline void clear_last_updated();

        static const int kLastUpdatedFieldNumber = 6;

        inline const ::message::timestamp &last_updated() const;

        inline ::message::timestamp *mutable_last_updated();

        inline ::message::timestamp *release_last_updated();

        inline void set_allocated_last_updated(::message::timestamp *last_updated);

        // @@protoc_insertion_point(class_scope:message.status)
    private:
        inline void set_has_tcp_id();

        inline void clear_has_tcp_id();

        inline void set_has_task_id();

        inline void clear_has_task_id();

        inline void set_has_description();

        inline void clear_has_description();

        inline void set_has_percentage();

        inline void clear_has_percentage();

        inline void set_has_buffer();

        inline void clear_has_buffer();

        inline void set_has_last_updated();

        inline void clear_has_last_updated();

        ::google::protobuf::UnknownFieldSet _unknown_fields_;

        ::google::protobuf::uint32 _has_bits_[1];
        mutable int _cached_size_;
        ::message::tcp_id *tcp_id_;
        ::std::string *description_;
        ::google::protobuf::int32 task_id_;
        ::google::protobuf::int32 percentage_;
        ::std::string *buffer_;
        ::message::timestamp *last_updated_;

        friend void protobuf_AddDesc_mes_2eud_2eproto();

        friend void protobuf_AssignDesc_mes_2eud_2eproto();

        friend void protobuf_ShutdownFile_mes_2eud_2eproto();

        void InitAsDefaultInstance();

        static status *default_instance_;
    };
// ===================================================================


// ===================================================================

// task_job

// required .message.task.type job_type = 1;
    inline bool task_job::has_job_type() const {
        return (_has_bits_[0] & 0x00000001u) != 0;
    }

    inline void task_job::set_has_job_type() {
        _has_bits_[0] |= 0x00000001u;
    }

    inline void task_job::clear_has_job_type() {
        _has_bits_[0] &= ~0x00000001u;
    }

    inline void task_job::clear_job_type() {
        job_type_ = 0;
        clear_has_job_type();
    }

    inline ::message::task_type task_job::job_type() const {
        // @@protoc_insertion_point(field_get:message.task.job.job_type)
        return static_cast< ::message::task_type >(job_type_);
    }

    inline void task_job::set_job_type(::message::task_type value) {
        assert(::message::task_type_IsValid(value));
        set_has_job_type();
        job_type_ = value;
        // @@protoc_insertion_point(field_set:message.task.job.job_type)
    }

// optional string file_path = 2;
    inline bool task_job::has_file_path() const {
        return (_has_bits_[0] & 0x00000002u) != 0;
    }

    inline void task_job::set_has_file_path() {
        _has_bits_[0] |= 0x00000002u;
    }

    inline void task_job::clear_has_file_path() {
        _has_bits_[0] &= ~0x00000002u;
    }

    inline void task_job::clear_file_path() {
        if (file_path_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            file_path_->clear();
        }
        clear_has_file_path();
    }

    inline const ::std::string &task_job::file_path() const {
        // @@protoc_insertion_point(field_get:message.task.job.file_path)
        return *file_path_;
    }

    inline void task_job::set_file_path(const ::std::string &value) {
        set_has_file_path();
        if (file_path_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            file_path_ = new ::std::string;
        }
        file_path_->assign(value);
        // @@protoc_insertion_point(field_set:message.task.job.file_path)
    }

    inline void task_job::set_file_path(const char *value) {
        set_has_file_path();
        if (file_path_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            file_path_ = new ::std::string;
        }
        file_path_->assign(value);
        // @@protoc_insertion_point(field_set_char:message.task.job.file_path)
    }

    inline void task_job::set_file_path(const char *value, size_t size) {
        set_has_file_path();
        if (file_path_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            file_path_ = new ::std::string;
        }
        file_path_->assign(reinterpret_cast<const char *>(value), size);
        // @@protoc_insertion_point(field_set_pointer:message.task.job.file_path)
    }

    inline ::std::string *task_job::mutable_file_path() {
        set_has_file_path();
        if (file_path_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            file_path_ = new ::std::string;
        }
        // @@protoc_insertion_point(field_mutable:message.task.job.file_path)
        return file_path_;
    }

    inline ::std::string *task_job::release_file_path() {
        clear_has_file_path();
        if (file_path_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            return NULL;
        } else {
            ::std::string *temp = file_path_;
            file_path_ = const_cast< ::std::string *>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
            return temp;
        }
    }

    inline void task_job::set_allocated_file_path(::std::string *file_path) {
        if (file_path_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            delete file_path_;
        }
        if (file_path) {
            set_has_file_path();
            file_path_ = file_path;
        } else {
            clear_has_file_path();
            file_path_ = const_cast< ::std::string *>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
        }
        // @@protoc_insertion_point(field_set_allocated:message.task.job.file_path)
    }

// optional string description = 3;
    inline bool task_job::has_description() const {
        return (_has_bits_[0] & 0x00000004u) != 0;
    }

    inline void task_job::set_has_description() {
        _has_bits_[0] |= 0x00000004u;
    }

    inline void task_job::clear_has_description() {
        _has_bits_[0] &= ~0x00000004u;
    }

    inline void task_job::clear_description() {
        if (description_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            description_->clear();
        }
        clear_has_description();
    }

    inline const ::std::string &task_job::description() const {
        // @@protoc_insertion_point(field_get:message.task.job.description)
        return *description_;
    }

    inline void task_job::set_description(const ::std::string &value) {
        set_has_description();
        if (description_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            description_ = new ::std::string;
        }
        description_->assign(value);
        // @@protoc_insertion_point(field_set:message.task.job.description)
    }

    inline void task_job::set_description(const char *value) {
        set_has_description();
        if (description_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            description_ = new ::std::string;
        }
        description_->assign(value);
        // @@protoc_insertion_point(field_set_char:message.task.job.description)
    }

    inline void task_job::set_description(const char *value, size_t size) {
        set_has_description();
        if (description_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            description_ = new ::std::string;
        }
        description_->assign(reinterpret_cast<const char *>(value), size);
        // @@protoc_insertion_point(field_set_pointer:message.task.job.description)
    }

    inline ::std::string *task_job::mutable_description() {
        set_has_description();
        if (description_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            description_ = new ::std::string;
        }
        // @@protoc_insertion_point(field_mutable:message.task.job.description)
        return description_;
    }

    inline ::std::string *task_job::release_description() {
        clear_has_description();
        if (description_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            return NULL;
        } else {
            ::std::string *temp = description_;
            description_ = const_cast< ::std::string *>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
            return temp;
        }
    }

    inline void task_job::set_allocated_description(::std::string *description) {
        if (description_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            delete description_;
        }
        if (description) {
            set_has_description();
            description_ = description;
        } else {
            clear_has_description();
            description_ = const_cast< ::std::string *>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
        }
        // @@protoc_insertion_point(field_set_allocated:message.task.job.description)
    }

// -------------------------------------------------------------------

// task

// required .message.tcp_id tcp_id = 1;
    inline bool task::has_tcp_id() const {
        return (_has_bits_[0] & 0x00000001u) != 0;
    }

    inline void task::set_has_tcp_id() {
        _has_bits_[0] |= 0x00000001u;
    }

    inline void task::clear_has_tcp_id() {
        _has_bits_[0] &= ~0x00000001u;
    }

    inline void task::clear_tcp_id() {
        if (tcp_id_ != NULL) tcp_id_->::message::tcp_id::Clear();
        clear_has_tcp_id();
    }

    inline const ::message::tcp_id &task::tcp_id() const {
        // @@protoc_insertion_point(field_get:message.task.tcp_id)
        return tcp_id_ != NULL ? *tcp_id_ : *default_instance_->tcp_id_;
    }

    inline ::message::tcp_id *task::mutable_tcp_id() {
        set_has_tcp_id();
        if (tcp_id_ == NULL) tcp_id_ = new ::message::tcp_id;
        // @@protoc_insertion_point(field_mutable:message.task.tcp_id)
        return tcp_id_;
    }

    inline ::message::tcp_id *task::release_tcp_id() {
        clear_has_tcp_id();
        ::message::tcp_id *temp = tcp_id_;
        tcp_id_ = NULL;
        return temp;
    }

    inline void task::set_allocated_tcp_id(::message::tcp_id *tcp_id) {
        delete tcp_id_;
        tcp_id_ = tcp_id;
        if (tcp_id) {
            set_has_tcp_id();
        } else {
            clear_has_tcp_id();
        }
        // @@protoc_insertion_point(field_set_allocated:message.task.tcp_id)
    }

// required int32 task_id = 2;
    inline bool task::has_task_id() const {
        return (_has_bits_[0] & 0x00000002u) != 0;
    }

    inline void task::set_has_task_id() {
        _has_bits_[0] |= 0x00000002u;
    }

    inline void task::clear_has_task_id() {
        _has_bits_[0] &= ~0x00000002u;
    }

    inline void task::clear_task_id() {
        task_id_ = 0;
        clear_has_task_id();
    }

    inline ::google::protobuf::int32 task::task_id() const {
        // @@protoc_insertion_point(field_get:message.task.task_id)
        return task_id_;
    }

    inline void task::set_task_id(::google::protobuf::int32 value) {
        set_has_task_id();
        task_id_ = value;
        // @@protoc_insertion_point(field_set:message.task.task_id)
    }

// repeated .message.task.job jobs = 3;
    inline int task::jobs_size() const {
        return jobs_.size();
    }

    inline void task::clear_jobs() {
        jobs_.Clear();
    }

    inline const ::message::task_job &task::jobs(int index) const {
        // @@protoc_insertion_point(field_get:message.task.jobs)
        return jobs_.Get(index);
    }

    inline ::message::task_job *task::mutable_jobs(int index) {
        // @@protoc_insertion_point(field_mutable:message.task.jobs)
        return jobs_.Mutable(index);
    }

    inline ::message::task_job *task::add_jobs() {
        // @@protoc_insertion_point(field_add:message.task.jobs)
        return jobs_.Add();
    }

    inline const ::google::protobuf::RepeatedPtrField<::message::task_job> &
    task::jobs() const {
        // @@protoc_insertion_point(field_list:message.task.jobs)
        return jobs_;
    }

    inline ::google::protobuf::RepeatedPtrField<::message::task_job> *
    task::mutable_jobs() {
        // @@protoc_insertion_point(field_mutable_list:message.task.jobs)
        return &jobs_;
    }

// optional .message.timestamp last_updated = 4;
    inline bool task::has_last_updated() const {
        return (_has_bits_[0] & 0x00000008u) != 0;
    }

    inline void task::set_has_last_updated() {
        _has_bits_[0] |= 0x00000008u;
    }

    inline void task::clear_has_last_updated() {
        _has_bits_[0] &= ~0x00000008u;
    }

    inline void task::clear_last_updated() {
        if (last_updated_ != NULL) last_updated_->::message::timestamp::Clear();
        clear_has_last_updated();
    }

    inline const ::message::timestamp &task::last_updated() const {
        // @@protoc_insertion_point(field_get:message.task.last_updated)
        return last_updated_ != NULL ? *last_updated_ : *default_instance_->last_updated_;
    }

    inline ::message::timestamp *task::mutable_last_updated() {
        set_has_last_updated();
        if (last_updated_ == NULL) last_updated_ = new ::message::timestamp;
        // @@protoc_insertion_point(field_mutable:message.task.last_updated)
        return last_updated_;
    }

    inline ::message::timestamp *task::release_last_updated() {
        clear_has_last_updated();
        ::message::timestamp *temp = last_updated_;
        last_updated_ = NULL;
        return temp;
    }

    inline void task::set_allocated_last_updated(::message::timestamp *last_updated) {
        delete last_updated_;
        last_updated_ = last_updated;
        if (last_updated) {
            set_has_last_updated();
        } else {
            clear_has_last_updated();
        }
        // @@protoc_insertion_point(field_set_allocated:message.task.last_updated)
    }

// -------------------------------------------------------------------

// status

// required .message.tcp_id tcp_id = 1;
    inline bool status::has_tcp_id() const {
        return (_has_bits_[0] & 0x00000001u) != 0;
    }

    inline void status::set_has_tcp_id() {
        _has_bits_[0] |= 0x00000001u;
    }

    inline void status::clear_has_tcp_id() {
        _has_bits_[0] &= ~0x00000001u;
    }

    inline void status::clear_tcp_id() {
        if (tcp_id_ != NULL) tcp_id_->::message::tcp_id::Clear();
        clear_has_tcp_id();
    }

    inline const ::message::tcp_id &status::tcp_id() const {
        // @@protoc_insertion_point(field_get:message.status.tcp_id)
        return tcp_id_ != NULL ? *tcp_id_ : *default_instance_->tcp_id_;
    }

    inline ::message::tcp_id *status::mutable_tcp_id() {
        set_has_tcp_id();
        if (tcp_id_ == NULL) tcp_id_ = new ::message::tcp_id;
        // @@protoc_insertion_point(field_mutable:message.status.tcp_id)
        return tcp_id_;
    }

    inline ::message::tcp_id *status::release_tcp_id() {
        clear_has_tcp_id();
        ::message::tcp_id *temp = tcp_id_;
        tcp_id_ = NULL;
        return temp;
    }

    inline void status::set_allocated_tcp_id(::message::tcp_id *tcp_id) {
        delete tcp_id_;
        tcp_id_ = tcp_id;
        if (tcp_id) {
            set_has_tcp_id();
        } else {
            clear_has_tcp_id();
        }
        // @@protoc_insertion_point(field_set_allocated:message.status.tcp_id)
    }

// required int32 task_id = 2;
    inline bool status::has_task_id() const {
        return (_has_bits_[0] & 0x00000002u) != 0;
    }

    inline void status::set_has_task_id() {
        _has_bits_[0] |= 0x00000002u;
    }

    inline void status::clear_has_task_id() {
        _has_bits_[0] &= ~0x00000002u;
    }

    inline void status::clear_task_id() {
        task_id_ = 0;
        clear_has_task_id();
    }

    inline ::google::protobuf::int32 status::task_id() const {
        // @@protoc_insertion_point(field_get:message.status.task_id)
        return task_id_;
    }

    inline void status::set_task_id(::google::protobuf::int32 value) {
        set_has_task_id();
        task_id_ = value;
        // @@protoc_insertion_point(field_set:message.status.task_id)
    }

// optional string description = 3;
    inline bool status::has_description() const {
        return (_has_bits_[0] & 0x00000004u) != 0;
    }

    inline void status::set_has_description() {
        _has_bits_[0] |= 0x00000004u;
    }

    inline void status::clear_has_description() {
        _has_bits_[0] &= ~0x00000004u;
    }

    inline void status::clear_description() {
        if (description_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            description_->clear();
        }
        clear_has_description();
    }

    inline const ::std::string &status::description() const {
        // @@protoc_insertion_point(field_get:message.status.description)
        return *description_;
    }

    inline void status::set_description(const ::std::string &value) {
        set_has_description();
        if (description_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            description_ = new ::std::string;
        }
        description_->assign(value);
        // @@protoc_insertion_point(field_set:message.status.description)
    }

    inline void status::set_description(const char *value) {
        set_has_description();
        if (description_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            description_ = new ::std::string;
        }
        description_->assign(value);
        // @@protoc_insertion_point(field_set_char:message.status.description)
    }

    inline void status::set_description(const char *value, size_t size) {
        set_has_description();
        if (description_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            description_ = new ::std::string;
        }
        description_->assign(reinterpret_cast<const char *>(value), size);
        // @@protoc_insertion_point(field_set_pointer:message.status.description)
    }

    inline ::std::string *status::mutable_description() {
        set_has_description();
        if (description_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            description_ = new ::std::string;
        }
        // @@protoc_insertion_point(field_mutable:message.status.description)
        return description_;
    }

    inline ::std::string *status::release_description() {
        clear_has_description();
        if (description_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            return NULL;
        } else {
            ::std::string *temp = description_;
            description_ = const_cast< ::std::string *>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
            return temp;
        }
    }

    inline void status::set_allocated_description(::std::string *description) {
        if (description_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            delete description_;
        }
        if (description) {
            set_has_description();
            description_ = description;
        } else {
            clear_has_description();
            description_ = const_cast< ::std::string *>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
        }
        // @@protoc_insertion_point(field_set_allocated:message.status.description)
    }

// optional int32 percentage = 4;
    inline bool status::has_percentage() const {
        return (_has_bits_[0] & 0x00000008u) != 0;
    }

    inline void status::set_has_percentage() {
        _has_bits_[0] |= 0x00000008u;
    }

    inline void status::clear_has_percentage() {
        _has_bits_[0] &= ~0x00000008u;
    }

    inline void status::clear_percentage() {
        percentage_ = 0;
        clear_has_percentage();
    }

    inline ::google::protobuf::int32 status::percentage() const {
        // @@protoc_insertion_point(field_get:message.status.percentage)
        return percentage_;
    }

    inline void status::set_percentage(::google::protobuf::int32 value) {
        set_has_percentage();
        percentage_ = value;
        // @@protoc_insertion_point(field_set:message.status.percentage)
    }

// optional string buffer = 5;
    inline bool status::has_buffer() const {
        return (_has_bits_[0] & 0x00000010u) != 0;
    }

    inline void status::set_has_buffer() {
        _has_bits_[0] |= 0x00000010u;
    }

    inline void status::clear_has_buffer() {
        _has_bits_[0] &= ~0x00000010u;
    }

    inline void status::clear_buffer() {
        if (buffer_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            buffer_->clear();
        }
        clear_has_buffer();
    }

    inline const ::std::string &status::buffer() const {
        // @@protoc_insertion_point(field_get:message.status.buffer)
        return *buffer_;
    }

    inline void status::set_buffer(const ::std::string &value) {
        set_has_buffer();
        if (buffer_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            buffer_ = new ::std::string;
        }
        buffer_->assign(value);
        // @@protoc_insertion_point(field_set:message.status.buffer)
    }

    inline void status::set_buffer(const char *value) {
        set_has_buffer();
        if (buffer_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            buffer_ = new ::std::string;
        }
        buffer_->assign(value);
        // @@protoc_insertion_point(field_set_char:message.status.buffer)
    }

    inline void status::set_buffer(const char *value, size_t size) {
        set_has_buffer();
        if (buffer_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            buffer_ = new ::std::string;
        }
        buffer_->assign(reinterpret_cast<const char *>(value), size);
        // @@protoc_insertion_point(field_set_pointer:message.status.buffer)
    }

    inline ::std::string *status::mutable_buffer() {
        set_has_buffer();
        if (buffer_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            buffer_ = new ::std::string;
        }
        // @@protoc_insertion_point(field_mutable:message.status.buffer)
        return buffer_;
    }

    inline ::std::string *status::release_buffer() {
        clear_has_buffer();
        if (buffer_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            return NULL;
        } else {
            ::std::string *temp = buffer_;
            buffer_ = const_cast< ::std::string *>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
            return temp;
        }
    }

    inline void status::set_allocated_buffer(::std::string *buffer) {
        if (buffer_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            delete buffer_;
        }
        if (buffer) {
            set_has_buffer();
            buffer_ = buffer;
        } else {
            clear_has_buffer();
            buffer_ = const_cast< ::std::string *>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
        }
        // @@protoc_insertion_point(field_set_allocated:message.status.buffer)
    }

// required .message.timestamp last_updated = 6;
    inline bool status::has_last_updated() const {
        return (_has_bits_[0] & 0x00000020u) != 0;
    }

    inline void status::set_has_last_updated() {
        _has_bits_[0] |= 0x00000020u;
    }

    inline void status::clear_has_last_updated() {
        _has_bits_[0] &= ~0x00000020u;
    }

    inline void status::clear_last_updated() {
        if (last_updated_ != NULL) last_updated_->::message::timestamp::Clear();
        clear_has_last_updated();
    }

    inline const ::message::timestamp &status::last_updated() const {
        // @@protoc_insertion_point(field_get:message.status.last_updated)
        return last_updated_ != NULL ? *last_updated_ : *default_instance_->last_updated_;
    }

    inline ::message::timestamp *status::mutable_last_updated() {
        set_has_last_updated();
        if (last_updated_ == NULL) last_updated_ = new ::message::timestamp;
        // @@protoc_insertion_point(field_mutable:message.status.last_updated)
        return last_updated_;
    }

    inline ::message::timestamp *status::release_last_updated() {
        clear_has_last_updated();
        ::message::timestamp *temp = last_updated_;
        last_updated_ = NULL;
        return temp;
    }

    inline void status::set_allocated_last_updated(::message::timestamp *last_updated) {
        delete last_updated_;
        last_updated_ = last_updated;
        if (last_updated) {
            set_has_last_updated();
        } else {
            clear_has_last_updated();
        }
        // @@protoc_insertion_point(field_set_allocated:message.status.last_updated)
    }


// @@protoc_insertion_point(namespace_scope)

}  // namespace message

#ifndef SWIG
namespace google {
    namespace protobuf {

        template<>
        struct is_proto_enum<::message::task_type> : ::google::protobuf::internal::true_type {
        };

        template<>
        inline const EnumDescriptor *GetEnumDescriptor<::message::task_type>() {
            return ::message::task_type_descriptor();
        }

    }  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_mes_2eud_2eproto__INCLUDED
