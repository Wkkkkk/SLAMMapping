// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: mes.base.proto

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION

#include "mes.base.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)

namespace message {

    namespace {

        const ::google::protobuf::Descriptor *timestamp_descriptor_ = NULL;
        const ::google::protobuf::internal::GeneratedMessageReflection *
                timestamp_reflection_ = NULL;
        const ::google::protobuf::Descriptor *tcp_id_descriptor_ = NULL;
        const ::google::protobuf::internal::GeneratedMessageReflection *
                tcp_id_reflection_ = NULL;

    }  // namespace


    void protobuf_AssignDesc_mes_2ebase_2eproto() {
        protobuf_AddDesc_mes_2ebase_2eproto();
        const ::google::protobuf::FileDescriptor *file =
                ::google::protobuf::DescriptorPool::generated_pool()->FindFileByName(
                        "mes.base.proto");
        GOOGLE_CHECK(file != NULL);
        timestamp_descriptor_ = file->message_type(0);
        static const int timestamp_offsets_[2] = {
                GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(timestamp, seconds_),
                GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(timestamp, nanos_),
        };
        timestamp_reflection_ =
                new ::google::protobuf::internal::GeneratedMessageReflection(
                        timestamp_descriptor_,
                        timestamp::default_instance_,
                        timestamp_offsets_,
                        GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(timestamp, _has_bits_[0]),
                        GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(timestamp, _unknown_fields_),
                        -1,
                        ::google::protobuf::DescriptorPool::generated_pool(),
                        ::google::protobuf::MessageFactory::generated_factory(),
                        sizeof(timestamp));
        tcp_id_descriptor_ = file->message_type(1);
        static const int tcp_id_offsets_[4] = {
                GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(tcp_id, ip_),
                GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(tcp_id, port_),
                GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(tcp_id, pid_),
                GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(tcp_id, connect_time_),
        };
        tcp_id_reflection_ =
                new ::google::protobuf::internal::GeneratedMessageReflection(
                        tcp_id_descriptor_,
                        tcp_id::default_instance_,
                        tcp_id_offsets_,
                        GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(tcp_id, _has_bits_[0]),
                        GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(tcp_id, _unknown_fields_),
                        -1,
                        ::google::protobuf::DescriptorPool::generated_pool(),
                        ::google::protobuf::MessageFactory::generated_factory(),
                        sizeof(tcp_id));
    }

    namespace {

        GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AssignDescriptors_once_);

        inline void protobuf_AssignDescriptorsOnce() {
            ::google::protobuf::GoogleOnceInit(&protobuf_AssignDescriptors_once_,
                                               &protobuf_AssignDesc_mes_2ebase_2eproto);
        }

        void protobuf_RegisterTypes(const ::std::string &) {
            protobuf_AssignDescriptorsOnce();
            ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
                    timestamp_descriptor_, &timestamp::default_instance());
            ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
                    tcp_id_descriptor_, &tcp_id::default_instance());
        }

    }  // namespace

    void protobuf_ShutdownFile_mes_2ebase_2eproto() {
        delete timestamp::default_instance_;
        delete timestamp_reflection_;
        delete tcp_id::default_instance_;
        delete tcp_id_reflection_;
    }

    void protobuf_AddDesc_mes_2ebase_2eproto() {
        static bool already_here = false;
        if (already_here) return;
        already_here = true;
        GOOGLE_PROTOBUF_VERIFY_VERSION;

        ::google::protobuf::DescriptorPool::InternalAddGeneratedFile(
                "\n\016mes.base.proto\022\007message\"+\n\ttimestamp\022\017"
                "\n\007seconds\030\001 \002(\003\022\r\n\005nanos\030\002 \001(\005\"Y\n\006tcp_id"
                "\022\n\n\002ip\030\001 \002(\t\022\014\n\004port\030\002 \002(\005\022\013\n\003pid\030\003 \002(\005\022"
                "(\n\014connect_time\030\004 \002(\0132\022.message.timestam"
                "p", 161);
        ::google::protobuf::MessageFactory::InternalRegisterGeneratedFile(
                "mes.base.proto", &protobuf_RegisterTypes);
        timestamp::default_instance_ = new timestamp();
        tcp_id::default_instance_ = new tcp_id();
        timestamp::default_instance_->InitAsDefaultInstance();
        tcp_id::default_instance_->InitAsDefaultInstance();
        ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_mes_2ebase_2eproto);
    }

// Force AddDescriptors() to be called at static initialization time.
    struct StaticDescriptorInitializer_mes_2ebase_2eproto {
        StaticDescriptorInitializer_mes_2ebase_2eproto() {
            protobuf_AddDesc_mes_2ebase_2eproto();
        }
    } static_descriptor_initializer_mes_2ebase_2eproto_;

// ===================================================================

#ifndef _MSC_VER
    const int timestamp::kSecondsFieldNumber;
    const int timestamp::kNanosFieldNumber;
#endif  // !_MSC_VER

    timestamp::timestamp()
            : ::google::protobuf::Message() {
        SharedCtor();
        // @@protoc_insertion_point(constructor:message.timestamp)
    }

    void timestamp::InitAsDefaultInstance() {
    }

    timestamp::timestamp(const timestamp &from)
            : ::google::protobuf::Message() {
        SharedCtor();
        MergeFrom(from);
        // @@protoc_insertion_point(copy_constructor:message.timestamp)
    }

    void timestamp::SharedCtor() {
        _cached_size_ = 0;
        seconds_ = GOOGLE_LONGLONG(0);
        nanos_ = 0;
        ::memset(_has_bits_, 0, sizeof(_has_bits_));
    }

    timestamp::~timestamp() {
        // @@protoc_insertion_point(destructor:message.timestamp)
        SharedDtor();
    }

    void timestamp::SharedDtor() {
        if (this != default_instance_) {
        }
    }

    void timestamp::SetCachedSize(int size) const {
        GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
        _cached_size_ = size;
        GOOGLE_SAFE_CONCURRENT_WRITES_END();
    }

    const ::google::protobuf::Descriptor *timestamp::descriptor() {
        protobuf_AssignDescriptorsOnce();
        return timestamp_descriptor_;
    }

    const timestamp &timestamp::default_instance() {
        if (default_instance_ == NULL) protobuf_AddDesc_mes_2ebase_2eproto();
        return *default_instance_;
    }

    timestamp *timestamp::default_instance_ = NULL;

    timestamp *timestamp::New() const {
        return new timestamp;
    }

    void timestamp::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<timestamp*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

        ZR_(seconds_, nanos_);

#undef OFFSET_OF_FIELD_
#undef ZR_

        ::memset(_has_bits_, 0, sizeof(_has_bits_));
        mutable_unknown_fields()->Clear();
    }

    bool timestamp::MergePartialFromCodedStream(
            ::google::protobuf::io::CodedInputStream *input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
        ::google::protobuf::uint32 tag;
        // @@protoc_insertion_point(parse_start:message.timestamp)
        for (;;) {
            ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
            tag = p.first;
            if (!p.second) goto handle_unusual;
            switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
                // required int64 seconds = 1;
                case 1: {
                    if (tag == 8) {
                        DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                                ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                                input, &seconds_)));
                        set_has_seconds();
                    } else {
                        goto handle_unusual;
                    }
                    if (input->ExpectTag(16)) goto parse_nanos;
                    break;
                }

                    // optional int32 nanos = 2;
                case 2: {
                    if (tag == 16) {
                        parse_nanos:
                        DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                                ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                                input, &nanos_)));
                        set_has_nanos();
                    } else {
                        goto handle_unusual;
                    }
                    if (input->ExpectAtEnd()) goto success;
                    break;
                }

                default: {
                    handle_unusual:
                    if (tag == 0 ||
                        ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
                        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
                        goto success;
                    }
                    DO_(::google::protobuf::internal::WireFormat::SkipField(
                            input, tag, mutable_unknown_fields()));
                    break;
                }
            }
        }
        success:
        // @@protoc_insertion_point(parse_success:message.timestamp)
        return true;
        failure:
        // @@protoc_insertion_point(parse_failure:message.timestamp)
        return false;
#undef DO_
    }

    void timestamp::SerializeWithCachedSizes(
            ::google::protobuf::io::CodedOutputStream *output) const {
        // @@protoc_insertion_point(serialize_start:message.timestamp)
        // required int64 seconds = 1;
        if (has_seconds()) {
            ::google::protobuf::internal::WireFormatLite::WriteInt64(1, this->seconds(), output);
        }

        // optional int32 nanos = 2;
        if (has_nanos()) {
            ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->nanos(), output);
        }

        if (!unknown_fields().empty()) {
            ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
                    unknown_fields(), output);
        }
        // @@protoc_insertion_point(serialize_end:message.timestamp)
    }

    ::google::protobuf::uint8 *timestamp::SerializeWithCachedSizesToArray(
            ::google::protobuf::uint8 *target) const {
        // @@protoc_insertion_point(serialize_to_array_start:message.timestamp)
        // required int64 seconds = 1;
        if (has_seconds()) {
            target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(1, this->seconds(), target);
        }

        // optional int32 nanos = 2;
        if (has_nanos()) {
            target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(2, this->nanos(), target);
        }

        if (!unknown_fields().empty()) {
            target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
                    unknown_fields(), target);
        }
        // @@protoc_insertion_point(serialize_to_array_end:message.timestamp)
        return target;
    }

    int timestamp::ByteSize() const {
        int total_size = 0;

        if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
            // required int64 seconds = 1;
            if (has_seconds()) {
                total_size += 1 +
                              ::google::protobuf::internal::WireFormatLite::Int64Size(
                                      this->seconds());
            }

            // optional int32 nanos = 2;
            if (has_nanos()) {
                total_size += 1 +
                              ::google::protobuf::internal::WireFormatLite::Int32Size(
                                      this->nanos());
            }

        }
        if (!unknown_fields().empty()) {
            total_size +=
                    ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
                            unknown_fields());
        }
        GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
        _cached_size_ = total_size;
        GOOGLE_SAFE_CONCURRENT_WRITES_END();
        return total_size;
    }

    void timestamp::MergeFrom(const ::google::protobuf::Message &from) {
        GOOGLE_CHECK_NE(&from, this);
        const timestamp *source =
                ::google::protobuf::internal::dynamic_cast_if_available<const timestamp *>(
                        &from);
        if (source == NULL) {
            ::google::protobuf::internal::ReflectionOps::Merge(from, this);
        } else {
            MergeFrom(*source);
        }
    }

    void timestamp::MergeFrom(const timestamp &from) {
        GOOGLE_CHECK_NE(&from, this);
        if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
            if (from.has_seconds()) {
                set_seconds(from.seconds());
            }
            if (from.has_nanos()) {
                set_nanos(from.nanos());
            }
        }
        mutable_unknown_fields()->MergeFrom(from.unknown_fields());
    }

    void timestamp::CopyFrom(const ::google::protobuf::Message &from) {
        if (&from == this) return;
        Clear();
        MergeFrom(from);
    }

    void timestamp::CopyFrom(const timestamp &from) {
        if (&from == this) return;
        Clear();
        MergeFrom(from);
    }

    bool timestamp::IsInitialized() const {
        if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

        return true;
    }

    void timestamp::Swap(timestamp *other) {
        if (other != this) {
            std::swap(seconds_, other->seconds_);
            std::swap(nanos_, other->nanos_);
            std::swap(_has_bits_[0], other->_has_bits_[0]);
            _unknown_fields_.Swap(&other->_unknown_fields_);
            std::swap(_cached_size_, other->_cached_size_);
        }
    }

    ::google::protobuf::Metadata timestamp::GetMetadata() const {
        protobuf_AssignDescriptorsOnce();
        ::google::protobuf::Metadata metadata;
        metadata.descriptor = timestamp_descriptor_;
        metadata.reflection = timestamp_reflection_;
        return metadata;
    }


// ===================================================================

#ifndef _MSC_VER
    const int tcp_id::kIpFieldNumber;
    const int tcp_id::kPortFieldNumber;
    const int tcp_id::kPidFieldNumber;
    const int tcp_id::kConnectTimeFieldNumber;
#endif  // !_MSC_VER

    tcp_id::tcp_id()
            : ::google::protobuf::Message() {
        SharedCtor();
        // @@protoc_insertion_point(constructor:message.tcp_id)
    }

    void tcp_id::InitAsDefaultInstance() {
        connect_time_ = const_cast< ::message::timestamp *>(&::message::timestamp::default_instance());
    }

    tcp_id::tcp_id(const tcp_id &from)
            : ::google::protobuf::Message() {
        SharedCtor();
        MergeFrom(from);
        // @@protoc_insertion_point(copy_constructor:message.tcp_id)
    }

    void tcp_id::SharedCtor() {
        ::google::protobuf::internal::GetEmptyString();
        _cached_size_ = 0;
        ip_ = const_cast< ::std::string *>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
        port_ = 0;
        pid_ = 0;
        connect_time_ = NULL;
        ::memset(_has_bits_, 0, sizeof(_has_bits_));
    }

    tcp_id::~tcp_id() {
        // @@protoc_insertion_point(destructor:message.tcp_id)
        SharedDtor();
    }

    void tcp_id::SharedDtor() {
        if (ip_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            delete ip_;
        }
        if (this != default_instance_) {
            delete connect_time_;
        }
    }

    void tcp_id::SetCachedSize(int size) const {
        GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
        _cached_size_ = size;
        GOOGLE_SAFE_CONCURRENT_WRITES_END();
    }

    const ::google::protobuf::Descriptor *tcp_id::descriptor() {
        protobuf_AssignDescriptorsOnce();
        return tcp_id_descriptor_;
    }

    const tcp_id &tcp_id::default_instance() {
        if (default_instance_ == NULL) protobuf_AddDesc_mes_2ebase_2eproto();
        return *default_instance_;
    }

    tcp_id *tcp_id::default_instance_ = NULL;

    tcp_id *tcp_id::New() const {
        return new tcp_id;
    }

    void tcp_id::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<tcp_id*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

        if (_has_bits_[0 / 32] & 15) {
            ZR_(port_, pid_);
            if (has_ip()) {
                if (ip_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
                    ip_->clear();
                }
            }
            if (has_connect_time()) {
                if (connect_time_ != NULL) connect_time_->::message::timestamp::Clear();
            }
        }

#undef OFFSET_OF_FIELD_
#undef ZR_

        ::memset(_has_bits_, 0, sizeof(_has_bits_));
        mutable_unknown_fields()->Clear();
    }

    bool tcp_id::MergePartialFromCodedStream(
            ::google::protobuf::io::CodedInputStream *input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
        ::google::protobuf::uint32 tag;
        // @@protoc_insertion_point(parse_start:message.tcp_id)
        for (;;) {
            ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
            tag = p.first;
            if (!p.second) goto handle_unusual;
            switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
                // required string ip = 1;
                case 1: {
                    if (tag == 10) {
                        DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                                input, this->mutable_ip()));
                        ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
                                this->ip().data(), this->ip().length(),
                                ::google::protobuf::internal::WireFormat::PARSE,
                                "ip");
                    } else {
                        goto handle_unusual;
                    }
                    if (input->ExpectTag(16)) goto parse_port;
                    break;
                }

                    // required int32 port = 2;
                case 2: {
                    if (tag == 16) {
                        parse_port:
                        DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                                ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                                input, &port_)));
                        set_has_port();
                    } else {
                        goto handle_unusual;
                    }
                    if (input->ExpectTag(24)) goto parse_pid;
                    break;
                }

                    // required int32 pid = 3;
                case 3: {
                    if (tag == 24) {
                        parse_pid:
                        DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                                ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                                input, &pid_)));
                        set_has_pid();
                    } else {
                        goto handle_unusual;
                    }
                    if (input->ExpectTag(34)) goto parse_connect_time;
                    break;
                }

                    // required .message.timestamp connect_time = 4;
                case 4: {
                    if (tag == 34) {
                        parse_connect_time:
                        DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                                input, mutable_connect_time()));
                    } else {
                        goto handle_unusual;
                    }
                    if (input->ExpectAtEnd()) goto success;
                    break;
                }

                default: {
                    handle_unusual:
                    if (tag == 0 ||
                        ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
                        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
                        goto success;
                    }
                    DO_(::google::protobuf::internal::WireFormat::SkipField(
                            input, tag, mutable_unknown_fields()));
                    break;
                }
            }
        }
        success:
        // @@protoc_insertion_point(parse_success:message.tcp_id)
        return true;
        failure:
        // @@protoc_insertion_point(parse_failure:message.tcp_id)
        return false;
#undef DO_
    }

    void tcp_id::SerializeWithCachedSizes(
            ::google::protobuf::io::CodedOutputStream *output) const {
        // @@protoc_insertion_point(serialize_start:message.tcp_id)
        // required string ip = 1;
        if (has_ip()) {
            ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
                    this->ip().data(), this->ip().length(),
                    ::google::protobuf::internal::WireFormat::SERIALIZE,
                    "ip");
            ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
                    1, this->ip(), output);
        }

        // required int32 port = 2;
        if (has_port()) {
            ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->port(), output);
        }

        // required int32 pid = 3;
        if (has_pid()) {
            ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->pid(), output);
        }

        // required .message.timestamp connect_time = 4;
        if (has_connect_time()) {
            ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
                    4, this->connect_time(), output);
        }

        if (!unknown_fields().empty()) {
            ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
                    unknown_fields(), output);
        }
        // @@protoc_insertion_point(serialize_end:message.tcp_id)
    }

    ::google::protobuf::uint8 *tcp_id::SerializeWithCachedSizesToArray(
            ::google::protobuf::uint8 *target) const {
        // @@protoc_insertion_point(serialize_to_array_start:message.tcp_id)
        // required string ip = 1;
        if (has_ip()) {
            ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
                    this->ip().data(), this->ip().length(),
                    ::google::protobuf::internal::WireFormat::SERIALIZE,
                    "ip");
            target =
                    ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
                            1, this->ip(), target);
        }

        // required int32 port = 2;
        if (has_port()) {
            target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(2, this->port(), target);
        }

        // required int32 pid = 3;
        if (has_pid()) {
            target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(3, this->pid(), target);
        }

        // required .message.timestamp connect_time = 4;
        if (has_connect_time()) {
            target = ::google::protobuf::internal::WireFormatLite::
            WriteMessageNoVirtualToArray(
                    4, this->connect_time(), target);
        }

        if (!unknown_fields().empty()) {
            target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
                    unknown_fields(), target);
        }
        // @@protoc_insertion_point(serialize_to_array_end:message.tcp_id)
        return target;
    }

    int tcp_id::ByteSize() const {
        int total_size = 0;

        if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
            // required string ip = 1;
            if (has_ip()) {
                total_size += 1 +
                              ::google::protobuf::internal::WireFormatLite::StringSize(
                                      this->ip());
            }

            // required int32 port = 2;
            if (has_port()) {
                total_size += 1 +
                              ::google::protobuf::internal::WireFormatLite::Int32Size(
                                      this->port());
            }

            // required int32 pid = 3;
            if (has_pid()) {
                total_size += 1 +
                              ::google::protobuf::internal::WireFormatLite::Int32Size(
                                      this->pid());
            }

            // required .message.timestamp connect_time = 4;
            if (has_connect_time()) {
                total_size += 1 +
                              ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
                                      this->connect_time());
            }

        }
        if (!unknown_fields().empty()) {
            total_size +=
                    ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
                            unknown_fields());
        }
        GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
        _cached_size_ = total_size;
        GOOGLE_SAFE_CONCURRENT_WRITES_END();
        return total_size;
    }

    void tcp_id::MergeFrom(const ::google::protobuf::Message &from) {
        GOOGLE_CHECK_NE(&from, this);
        const tcp_id *source =
                ::google::protobuf::internal::dynamic_cast_if_available<const tcp_id *>(
                        &from);
        if (source == NULL) {
            ::google::protobuf::internal::ReflectionOps::Merge(from, this);
        } else {
            MergeFrom(*source);
        }
    }

    void tcp_id::MergeFrom(const tcp_id &from) {
        GOOGLE_CHECK_NE(&from, this);
        if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
            if (from.has_ip()) {
                set_ip(from.ip());
            }
            if (from.has_port()) {
                set_port(from.port());
            }
            if (from.has_pid()) {
                set_pid(from.pid());
            }
            if (from.has_connect_time()) {
                mutable_connect_time()->::message::timestamp::MergeFrom(from.connect_time());
            }
        }
        mutable_unknown_fields()->MergeFrom(from.unknown_fields());
    }

    void tcp_id::CopyFrom(const ::google::protobuf::Message &from) {
        if (&from == this) return;
        Clear();
        MergeFrom(from);
    }

    void tcp_id::CopyFrom(const tcp_id &from) {
        if (&from == this) return;
        Clear();
        MergeFrom(from);
    }

    bool tcp_id::IsInitialized() const {
        if ((_has_bits_[0] & 0x0000000f) != 0x0000000f) return false;

        if (has_connect_time()) {
            if (!this->connect_time().IsInitialized()) return false;
        }
        return true;
    }

    void tcp_id::Swap(tcp_id *other) {
        if (other != this) {
            std::swap(ip_, other->ip_);
            std::swap(port_, other->port_);
            std::swap(pid_, other->pid_);
            std::swap(connect_time_, other->connect_time_);
            std::swap(_has_bits_[0], other->_has_bits_[0]);
            _unknown_fields_.Swap(&other->_unknown_fields_);
            std::swap(_cached_size_, other->_cached_size_);
        }
    }

    ::google::protobuf::Metadata tcp_id::GetMetadata() const {
        protobuf_AssignDescriptorsOnce();
        ::google::protobuf::Metadata metadata;
        metadata.descriptor = tcp_id_descriptor_;
        metadata.reflection = tcp_id_reflection_;
        return metadata;
    }


// @@protoc_insertion_point(namespace_scope)

}  // namespace message

// @@protoc_insertion_point(global_scope)
