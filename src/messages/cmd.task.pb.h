// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: cmd.task.proto

#ifndef PROTOBUF_cmd_2etask_2eproto__INCLUDED
#define PROTOBUF_cmd_2etask_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace cmd {

// Internal implementation detail -- do not call these.
    void protobuf_AddDesc_cmd_2etask_2eproto();

    void protobuf_AssignDesc_cmd_2etask_2eproto();

    void protobuf_ShutdownFile_cmd_2etask_2eproto();

    class task;

    class task_job;

    enum task_JobType {
        task_JobType_CALCULATE = 0,
        task_JobType_FILE_TRANSFER = 1,
        task_JobType_END = 2
    };

    bool task_JobType_IsValid(int value);

    const task_JobType task_JobType_JobType_MIN = task_JobType_CALCULATE;
    const task_JobType task_JobType_JobType_MAX = task_JobType_END;
    const int task_JobType_JobType_ARRAYSIZE = task_JobType_JobType_MAX + 1;

    const ::google::protobuf::EnumDescriptor *task_JobType_descriptor();

    inline const ::std::string &task_JobType_Name(task_JobType value) {
        return ::google::protobuf::internal::NameOfEnum(
                task_JobType_descriptor(), value);
    }

    inline bool task_JobType_Parse(
            const ::std::string &name, task_JobType *value) {
        return ::google::protobuf::internal::ParseNamedEnum<task_JobType>(
                task_JobType_descriptor(), name, value);
    }
// ===================================================================

    class task_job : public ::google::protobuf::Message {
    public:
        task_job();

        virtual ~task_job();

        task_job(const task_job &from);

        inline task_job &operator=(const task_job &from) {
            CopyFrom(from);
            return *this;
        }

        inline const ::google::protobuf::UnknownFieldSet &unknown_fields() const {
            return _unknown_fields_;
        }

        inline ::google::protobuf::UnknownFieldSet *mutable_unknown_fields() {
            return &_unknown_fields_;
        }

        static const ::google::protobuf::Descriptor *descriptor();

        static const task_job &default_instance();

        void Swap(task_job *other);

        // implements Message ----------------------------------------------

        task_job *New() const;

        void CopyFrom(const ::google::protobuf::Message &from);

        void MergeFrom(const ::google::protobuf::Message &from);

        void CopyFrom(const task_job &from);

        void MergeFrom(const task_job &from);

        void Clear();

        bool IsInitialized() const;

        int ByteSize() const;

        bool MergePartialFromCodedStream(
                ::google::protobuf::io::CodedInputStream *input);

        void SerializeWithCachedSizes(
                ::google::protobuf::io::CodedOutputStream *output) const;

        ::google::protobuf::uint8 *SerializeWithCachedSizesToArray(::google::protobuf::uint8 *output) const;

        int GetCachedSize() const { return _cached_size_; }

    private:
        void SharedCtor();

        void SharedDtor();

        void SetCachedSize(int size) const;

    public:
        ::google::protobuf::Metadata GetMetadata() const;

        // nested types ----------------------------------------------------

        // accessors -------------------------------------------------------

        // required string file_path = 1;
        inline bool has_file_path() const;

        inline void clear_file_path();

        static const int kFilePathFieldNumber = 1;

        inline const ::std::string &file_path() const;

        inline void set_file_path(const ::std::string &value);

        inline void set_file_path(const char *value);

        inline void set_file_path(const char *value, size_t size);

        inline ::std::string *mutable_file_path();

        inline ::std::string *release_file_path();

        inline void set_allocated_file_path(::std::string *file_path);

        // required .cmd.task.JobType type = 2;
        inline bool has_type() const;

        inline void clear_type();

        static const int kTypeFieldNumber = 2;

        inline ::cmd::task_JobType type() const;

        inline void set_type(::cmd::task_JobType value);

        // optional string description = 3;
        inline bool has_description() const;

        inline void clear_description();

        static const int kDescriptionFieldNumber = 3;

        inline const ::std::string &description() const;

        inline void set_description(const ::std::string &value);

        inline void set_description(const char *value);

        inline void set_description(const char *value, size_t size);

        inline ::std::string *mutable_description();

        inline ::std::string *release_description();

        inline void set_allocated_description(::std::string *description);

        // @@protoc_insertion_point(class_scope:cmd.task.job)
    private:
        inline void set_has_file_path();

        inline void clear_has_file_path();

        inline void set_has_type();

        inline void clear_has_type();

        inline void set_has_description();

        inline void clear_has_description();

        ::google::protobuf::UnknownFieldSet _unknown_fields_;

        ::google::protobuf::uint32 _has_bits_[1];
        mutable int _cached_size_;
        ::std::string *file_path_;
        ::std::string *description_;
        int type_;

        friend void protobuf_AddDesc_cmd_2etask_2eproto();

        friend void protobuf_AssignDesc_cmd_2etask_2eproto();

        friend void protobuf_ShutdownFile_cmd_2etask_2eproto();

        void InitAsDefaultInstance();

        static task_job *default_instance_;
    };
// -------------------------------------------------------------------

    class task : public ::google::protobuf::Message {
    public:
        task();

        virtual ~task();

        task(const task &from);

        inline task &operator=(const task &from) {
            CopyFrom(from);
            return *this;
        }

        inline const ::google::protobuf::UnknownFieldSet &unknown_fields() const {
            return _unknown_fields_;
        }

        inline ::google::protobuf::UnknownFieldSet *mutable_unknown_fields() {
            return &_unknown_fields_;
        }

        static const ::google::protobuf::Descriptor *descriptor();

        static const task &default_instance();

        void Swap(task *other);

        // implements Message ----------------------------------------------

        task *New() const;

        void CopyFrom(const ::google::protobuf::Message &from);

        void MergeFrom(const ::google::protobuf::Message &from);

        void CopyFrom(const task &from);

        void MergeFrom(const task &from);

        void Clear();

        bool IsInitialized() const;

        int ByteSize() const;

        bool MergePartialFromCodedStream(
                ::google::protobuf::io::CodedInputStream *input);

        void SerializeWithCachedSizes(
                ::google::protobuf::io::CodedOutputStream *output) const;

        ::google::protobuf::uint8 *SerializeWithCachedSizesToArray(::google::protobuf::uint8 *output) const;

        int GetCachedSize() const { return _cached_size_; }

    private:
        void SharedCtor();

        void SharedDtor();

        void SetCachedSize(int size) const;

    public:
        ::google::protobuf::Metadata GetMetadata() const;

        // nested types ----------------------------------------------------

        typedef task_job job;

        typedef task_JobType JobType;
        static const JobType CALCULATE = task_JobType_CALCULATE;
        static const JobType FILE_TRANSFER = task_JobType_FILE_TRANSFER;
        static const JobType END = task_JobType_END;

        static inline bool JobType_IsValid(int value) {
            return task_JobType_IsValid(value);
        }

        static const JobType JobType_MIN =
                task_JobType_JobType_MIN;
        static const JobType JobType_MAX =
                task_JobType_JobType_MAX;
        static const int JobType_ARRAYSIZE =
                task_JobType_JobType_ARRAYSIZE;

        static inline const ::google::protobuf::EnumDescriptor *
        JobType_descriptor() {
            return task_JobType_descriptor();
        }

        static inline const ::std::string &JobType_Name(JobType value) {
            return task_JobType_Name(value);
        }

        static inline bool JobType_Parse(const ::std::string &name,
                                         JobType *value) {
            return task_JobType_Parse(name, value);
        }

        // accessors -------------------------------------------------------

        // required string ip = 1;
        inline bool has_ip() const;

        inline void clear_ip();

        static const int kIpFieldNumber = 1;

        inline const ::std::string &ip() const;

        inline void set_ip(const ::std::string &value);

        inline void set_ip(const char *value);

        inline void set_ip(const char *value, size_t size);

        inline ::std::string *mutable_ip();

        inline ::std::string *release_ip();

        inline void set_allocated_ip(::std::string *ip);

        // required int32 port = 2;
        inline bool has_port() const;

        inline void clear_port();

        static const int kPortFieldNumber = 2;

        inline ::google::protobuf::int32 port() const;

        inline void set_port(::google::protobuf::int32 value);

        // required int32 pid = 3;
        inline bool has_pid() const;

        inline void clear_pid();

        static const int kPidFieldNumber = 3;

        inline ::google::protobuf::int32 pid() const;

        inline void set_pid(::google::protobuf::int32 value);

        // required int32 id = 4;
        inline bool has_id() const;

        inline void clear_id();

        static const int kIdFieldNumber = 4;

        inline ::google::protobuf::int32 id() const;

        inline void set_id(::google::protobuf::int32 value);

        // repeated .cmd.task.job jobs = 5;
        inline int jobs_size() const;

        inline void clear_jobs();

        static const int kJobsFieldNumber = 5;

        inline const ::cmd::task_job &jobs(int index) const;

        inline ::cmd::task_job *mutable_jobs(int index);

        inline ::cmd::task_job *add_jobs();

        inline const ::google::protobuf::RepeatedPtrField<::cmd::task_job> &
        jobs() const;

        inline ::google::protobuf::RepeatedPtrField<::cmd::task_job> *
        mutable_jobs();

        // @@protoc_insertion_point(class_scope:cmd.task)
    private:
        inline void set_has_ip();

        inline void clear_has_ip();

        inline void set_has_port();

        inline void clear_has_port();

        inline void set_has_pid();

        inline void clear_has_pid();

        inline void set_has_id();

        inline void clear_has_id();

        ::google::protobuf::UnknownFieldSet _unknown_fields_;

        ::google::protobuf::uint32 _has_bits_[1];
        mutable int _cached_size_;
        ::std::string *ip_;
        ::google::protobuf::int32 port_;
        ::google::protobuf::int32 pid_;
        ::google::protobuf::RepeatedPtrField<::cmd::task_job> jobs_;
        ::google::protobuf::int32 id_;

        friend void protobuf_AddDesc_cmd_2etask_2eproto();

        friend void protobuf_AssignDesc_cmd_2etask_2eproto();

        friend void protobuf_ShutdownFile_cmd_2etask_2eproto();

        void InitAsDefaultInstance();

        static task *default_instance_;
    };
// ===================================================================


// ===================================================================

// task_job

// required string file_path = 1;
    inline bool task_job::has_file_path() const {
        return (_has_bits_[0] & 0x00000001u) != 0;
    }

    inline void task_job::set_has_file_path() {
        _has_bits_[0] |= 0x00000001u;
    }

    inline void task_job::clear_has_file_path() {
        _has_bits_[0] &= ~0x00000001u;
    }

    inline void task_job::clear_file_path() {
        if (file_path_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            file_path_->clear();
        }
        clear_has_file_path();
    }

    inline const ::std::string &task_job::file_path() const {
        // @@protoc_insertion_point(field_get:cmd.task.job.file_path)
        return *file_path_;
    }

    inline void task_job::set_file_path(const ::std::string &value) {
        set_has_file_path();
        if (file_path_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            file_path_ = new ::std::string;
        }
        file_path_->assign(value);
        // @@protoc_insertion_point(field_set:cmd.task.job.file_path)
    }

    inline void task_job::set_file_path(const char *value) {
        set_has_file_path();
        if (file_path_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            file_path_ = new ::std::string;
        }
        file_path_->assign(value);
        // @@protoc_insertion_point(field_set_char:cmd.task.job.file_path)
    }

    inline void task_job::set_file_path(const char *value, size_t size) {
        set_has_file_path();
        if (file_path_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            file_path_ = new ::std::string;
        }
        file_path_->assign(reinterpret_cast<const char *>(value), size);
        // @@protoc_insertion_point(field_set_pointer:cmd.task.job.file_path)
    }

    inline ::std::string *task_job::mutable_file_path() {
        set_has_file_path();
        if (file_path_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            file_path_ = new ::std::string;
        }
        // @@protoc_insertion_point(field_mutable:cmd.task.job.file_path)
        return file_path_;
    }

    inline ::std::string *task_job::release_file_path() {
        clear_has_file_path();
        if (file_path_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            return NULL;
        } else {
            ::std::string *temp = file_path_;
            file_path_ = const_cast< ::std::string *>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
            return temp;
        }
    }

    inline void task_job::set_allocated_file_path(::std::string *file_path) {
        if (file_path_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            delete file_path_;
        }
        if (file_path) {
            set_has_file_path();
            file_path_ = file_path;
        } else {
            clear_has_file_path();
            file_path_ = const_cast< ::std::string *>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
        }
        // @@protoc_insertion_point(field_set_allocated:cmd.task.job.file_path)
    }

// required .cmd.task.JobType type = 2;
    inline bool task_job::has_type() const {
        return (_has_bits_[0] & 0x00000002u) != 0;
    }

    inline void task_job::set_has_type() {
        _has_bits_[0] |= 0x00000002u;
    }

    inline void task_job::clear_has_type() {
        _has_bits_[0] &= ~0x00000002u;
    }

    inline void task_job::clear_type() {
        type_ = 0;
        clear_has_type();
    }

    inline ::cmd::task_JobType task_job::type() const {
        // @@protoc_insertion_point(field_get:cmd.task.job.type)
        return static_cast< ::cmd::task_JobType >(type_);
    }

    inline void task_job::set_type(::cmd::task_JobType value) {
        assert(::cmd::task_JobType_IsValid(value));
        set_has_type();
        type_ = value;
        // @@protoc_insertion_point(field_set:cmd.task.job.type)
    }

// optional string description = 3;
    inline bool task_job::has_description() const {
        return (_has_bits_[0] & 0x00000004u) != 0;
    }

    inline void task_job::set_has_description() {
        _has_bits_[0] |= 0x00000004u;
    }

    inline void task_job::clear_has_description() {
        _has_bits_[0] &= ~0x00000004u;
    }

    inline void task_job::clear_description() {
        if (description_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            description_->clear();
        }
        clear_has_description();
    }

    inline const ::std::string &task_job::description() const {
        // @@protoc_insertion_point(field_get:cmd.task.job.description)
        return *description_;
    }

    inline void task_job::set_description(const ::std::string &value) {
        set_has_description();
        if (description_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            description_ = new ::std::string;
        }
        description_->assign(value);
        // @@protoc_insertion_point(field_set:cmd.task.job.description)
    }

    inline void task_job::set_description(const char *value) {
        set_has_description();
        if (description_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            description_ = new ::std::string;
        }
        description_->assign(value);
        // @@protoc_insertion_point(field_set_char:cmd.task.job.description)
    }

    inline void task_job::set_description(const char *value, size_t size) {
        set_has_description();
        if (description_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            description_ = new ::std::string;
        }
        description_->assign(reinterpret_cast<const char *>(value), size);
        // @@protoc_insertion_point(field_set_pointer:cmd.task.job.description)
    }

    inline ::std::string *task_job::mutable_description() {
        set_has_description();
        if (description_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            description_ = new ::std::string;
        }
        // @@protoc_insertion_point(field_mutable:cmd.task.job.description)
        return description_;
    }

    inline ::std::string *task_job::release_description() {
        clear_has_description();
        if (description_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            return NULL;
        } else {
            ::std::string *temp = description_;
            description_ = const_cast< ::std::string *>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
            return temp;
        }
    }

    inline void task_job::set_allocated_description(::std::string *description) {
        if (description_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            delete description_;
        }
        if (description) {
            set_has_description();
            description_ = description;
        } else {
            clear_has_description();
            description_ = const_cast< ::std::string *>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
        }
        // @@protoc_insertion_point(field_set_allocated:cmd.task.job.description)
    }

// -------------------------------------------------------------------

// task

// required string ip = 1;
    inline bool task::has_ip() const {
        return (_has_bits_[0] & 0x00000001u) != 0;
    }

    inline void task::set_has_ip() {
        _has_bits_[0] |= 0x00000001u;
    }

    inline void task::clear_has_ip() {
        _has_bits_[0] &= ~0x00000001u;
    }

    inline void task::clear_ip() {
        if (ip_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            ip_->clear();
        }
        clear_has_ip();
    }

    inline const ::std::string &task::ip() const {
        // @@protoc_insertion_point(field_get:cmd.task.ip)
        return *ip_;
    }

    inline void task::set_ip(const ::std::string &value) {
        set_has_ip();
        if (ip_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            ip_ = new ::std::string;
        }
        ip_->assign(value);
        // @@protoc_insertion_point(field_set:cmd.task.ip)
    }

    inline void task::set_ip(const char *value) {
        set_has_ip();
        if (ip_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            ip_ = new ::std::string;
        }
        ip_->assign(value);
        // @@protoc_insertion_point(field_set_char:cmd.task.ip)
    }

    inline void task::set_ip(const char *value, size_t size) {
        set_has_ip();
        if (ip_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            ip_ = new ::std::string;
        }
        ip_->assign(reinterpret_cast<const char *>(value), size);
        // @@protoc_insertion_point(field_set_pointer:cmd.task.ip)
    }

    inline ::std::string *task::mutable_ip() {
        set_has_ip();
        if (ip_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            ip_ = new ::std::string;
        }
        // @@protoc_insertion_point(field_mutable:cmd.task.ip)
        return ip_;
    }

    inline ::std::string *task::release_ip() {
        clear_has_ip();
        if (ip_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            return NULL;
        } else {
            ::std::string *temp = ip_;
            ip_ = const_cast< ::std::string *>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
            return temp;
        }
    }

    inline void task::set_allocated_ip(::std::string *ip) {
        if (ip_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            delete ip_;
        }
        if (ip) {
            set_has_ip();
            ip_ = ip;
        } else {
            clear_has_ip();
            ip_ = const_cast< ::std::string *>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
        }
        // @@protoc_insertion_point(field_set_allocated:cmd.task.ip)
    }

// required int32 port = 2;
    inline bool task::has_port() const {
        return (_has_bits_[0] & 0x00000002u) != 0;
    }

    inline void task::set_has_port() {
        _has_bits_[0] |= 0x00000002u;
    }

    inline void task::clear_has_port() {
        _has_bits_[0] &= ~0x00000002u;
    }

    inline void task::clear_port() {
        port_ = 0;
        clear_has_port();
    }

    inline ::google::protobuf::int32 task::port() const {
        // @@protoc_insertion_point(field_get:cmd.task.port)
        return port_;
    }

    inline void task::set_port(::google::protobuf::int32 value) {
        set_has_port();
        port_ = value;
        // @@protoc_insertion_point(field_set:cmd.task.port)
    }

// required int32 pid = 3;
    inline bool task::has_pid() const {
        return (_has_bits_[0] & 0x00000004u) != 0;
    }

    inline void task::set_has_pid() {
        _has_bits_[0] |= 0x00000004u;
    }

    inline void task::clear_has_pid() {
        _has_bits_[0] &= ~0x00000004u;
    }

    inline void task::clear_pid() {
        pid_ = 0;
        clear_has_pid();
    }

    inline ::google::protobuf::int32 task::pid() const {
        // @@protoc_insertion_point(field_get:cmd.task.pid)
        return pid_;
    }

    inline void task::set_pid(::google::protobuf::int32 value) {
        set_has_pid();
        pid_ = value;
        // @@protoc_insertion_point(field_set:cmd.task.pid)
    }

// required int32 id = 4;
    inline bool task::has_id() const {
        return (_has_bits_[0] & 0x00000008u) != 0;
    }

    inline void task::set_has_id() {
        _has_bits_[0] |= 0x00000008u;
    }

    inline void task::clear_has_id() {
        _has_bits_[0] &= ~0x00000008u;
    }

    inline void task::clear_id() {
        id_ = 0;
        clear_has_id();
    }

    inline ::google::protobuf::int32 task::id() const {
        // @@protoc_insertion_point(field_get:cmd.task.id)
        return id_;
    }

    inline void task::set_id(::google::protobuf::int32 value) {
        set_has_id();
        id_ = value;
        // @@protoc_insertion_point(field_set:cmd.task.id)
    }

// repeated .cmd.task.job jobs = 5;
    inline int task::jobs_size() const {
        return jobs_.size();
    }

    inline void task::clear_jobs() {
        jobs_.Clear();
    }

    inline const ::cmd::task_job &task::jobs(int index) const {
        // @@protoc_insertion_point(field_get:cmd.task.jobs)
        return jobs_.Get(index);
    }

    inline ::cmd::task_job *task::mutable_jobs(int index) {
        // @@protoc_insertion_point(field_mutable:cmd.task.jobs)
        return jobs_.Mutable(index);
    }

    inline ::cmd::task_job *task::add_jobs() {
        // @@protoc_insertion_point(field_add:cmd.task.jobs)
        return jobs_.Add();
    }

    inline const ::google::protobuf::RepeatedPtrField<::cmd::task_job> &
    task::jobs() const {
        // @@protoc_insertion_point(field_list:cmd.task.jobs)
        return jobs_;
    }

    inline ::google::protobuf::RepeatedPtrField<::cmd::task_job> *
    task::mutable_jobs() {
        // @@protoc_insertion_point(field_mutable_list:cmd.task.jobs)
        return &jobs_;
    }


// @@protoc_insertion_point(namespace_scope)

}  // namespace cmd

#ifndef SWIG
namespace google {
    namespace protobuf {

        template<>
        struct is_proto_enum<::cmd::task_JobType> : ::google::protobuf::internal::true_type {
        };

        template<>
        inline const EnumDescriptor *GetEnumDescriptor<::cmd::task_JobType>() {
            return ::cmd::task_JobType_descriptor();
        }

    }  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_cmd_2etask_2eproto__INCLUDED
