// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: mes.base.proto

#ifndef PROTOBUF_mes_2ebase_2eproto__INCLUDED
#define PROTOBUF_mes_2ebase_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace message {

// Internal implementation detail -- do not call these.
    void protobuf_AddDesc_mes_2ebase_2eproto();

    void protobuf_AssignDesc_mes_2ebase_2eproto();

    void protobuf_ShutdownFile_mes_2ebase_2eproto();

    class timestamp;

    class tcp_id;

// ===================================================================

    class timestamp : public ::google::protobuf::Message {
    public:
        timestamp();

        virtual ~timestamp();

        timestamp(const timestamp &from);

        inline timestamp &operator=(const timestamp &from) {
            CopyFrom(from);
            return *this;
        }

        inline const ::google::protobuf::UnknownFieldSet &unknown_fields() const {
            return _unknown_fields_;
        }

        inline ::google::protobuf::UnknownFieldSet *mutable_unknown_fields() {
            return &_unknown_fields_;
        }

        static const ::google::protobuf::Descriptor *descriptor();

        static const timestamp &default_instance();

        void Swap(timestamp *other);

        // implements Message ----------------------------------------------

        timestamp *New() const;

        void CopyFrom(const ::google::protobuf::Message &from);

        void MergeFrom(const ::google::protobuf::Message &from);

        void CopyFrom(const timestamp &from);

        void MergeFrom(const timestamp &from);

        void Clear();

        bool IsInitialized() const;

        int ByteSize() const;

        bool MergePartialFromCodedStream(
                ::google::protobuf::io::CodedInputStream *input);

        void SerializeWithCachedSizes(
                ::google::protobuf::io::CodedOutputStream *output) const;

        ::google::protobuf::uint8 *SerializeWithCachedSizesToArray(::google::protobuf::uint8 *output) const;

        int GetCachedSize() const { return _cached_size_; }

    private:
        void SharedCtor();

        void SharedDtor();

        void SetCachedSize(int size) const;

    public:
        ::google::protobuf::Metadata GetMetadata() const;

        // nested types ----------------------------------------------------

        // accessors -------------------------------------------------------

        // required int64 seconds = 1;
        inline bool has_seconds() const;

        inline void clear_seconds();

        static const int kSecondsFieldNumber = 1;

        inline ::google::protobuf::int64 seconds() const;

        inline void set_seconds(::google::protobuf::int64 value);

        // optional int32 nanos = 2;
        inline bool has_nanos() const;

        inline void clear_nanos();

        static const int kNanosFieldNumber = 2;

        inline ::google::protobuf::int32 nanos() const;

        inline void set_nanos(::google::protobuf::int32 value);

        // @@protoc_insertion_point(class_scope:message.timestamp)
    private:
        inline void set_has_seconds();

        inline void clear_has_seconds();

        inline void set_has_nanos();

        inline void clear_has_nanos();

        ::google::protobuf::UnknownFieldSet _unknown_fields_;

        ::google::protobuf::uint32 _has_bits_[1];
        mutable int _cached_size_;
        ::google::protobuf::int64 seconds_;
        ::google::protobuf::int32 nanos_;

        friend void protobuf_AddDesc_mes_2ebase_2eproto();

        friend void protobuf_AssignDesc_mes_2ebase_2eproto();

        friend void protobuf_ShutdownFile_mes_2ebase_2eproto();

        void InitAsDefaultInstance();

        static timestamp *default_instance_;
    };
// -------------------------------------------------------------------

    class tcp_id : public ::google::protobuf::Message {
    public:
        tcp_id();

        virtual ~tcp_id();

        tcp_id(const tcp_id &from);

        inline tcp_id &operator=(const tcp_id &from) {
            CopyFrom(from);
            return *this;
        }

        inline const ::google::protobuf::UnknownFieldSet &unknown_fields() const {
            return _unknown_fields_;
        }

        inline ::google::protobuf::UnknownFieldSet *mutable_unknown_fields() {
            return &_unknown_fields_;
        }

        static const ::google::protobuf::Descriptor *descriptor();

        static const tcp_id &default_instance();

        void Swap(tcp_id *other);

        // implements Message ----------------------------------------------

        tcp_id *New() const;

        void CopyFrom(const ::google::protobuf::Message &from);

        void MergeFrom(const ::google::protobuf::Message &from);

        void CopyFrom(const tcp_id &from);

        void MergeFrom(const tcp_id &from);

        void Clear();

        bool IsInitialized() const;

        int ByteSize() const;

        bool MergePartialFromCodedStream(
                ::google::protobuf::io::CodedInputStream *input);

        void SerializeWithCachedSizes(
                ::google::protobuf::io::CodedOutputStream *output) const;

        ::google::protobuf::uint8 *SerializeWithCachedSizesToArray(::google::protobuf::uint8 *output) const;

        int GetCachedSize() const { return _cached_size_; }

    private:
        void SharedCtor();

        void SharedDtor();

        void SetCachedSize(int size) const;

    public:
        ::google::protobuf::Metadata GetMetadata() const;

        // nested types ----------------------------------------------------

        // accessors -------------------------------------------------------

        // required string ip = 1;
        inline bool has_ip() const;

        inline void clear_ip();

        static const int kIpFieldNumber = 1;

        inline const ::std::string &ip() const;

        inline void set_ip(const ::std::string &value);

        inline void set_ip(const char *value);

        inline void set_ip(const char *value, size_t size);

        inline ::std::string *mutable_ip();

        inline ::std::string *release_ip();

        inline void set_allocated_ip(::std::string *ip);

        // required int32 port = 2;
        inline bool has_port() const;

        inline void clear_port();

        static const int kPortFieldNumber = 2;

        inline ::google::protobuf::int32 port() const;

        inline void set_port(::google::protobuf::int32 value);

        // required int32 pid = 3;
        inline bool has_pid() const;

        inline void clear_pid();

        static const int kPidFieldNumber = 3;

        inline ::google::protobuf::int32 pid() const;

        inline void set_pid(::google::protobuf::int32 value);

        // required .message.timestamp connect_time = 4;
        inline bool has_connect_time() const;

        inline void clear_connect_time();

        static const int kConnectTimeFieldNumber = 4;

        inline const ::message::timestamp &connect_time() const;

        inline ::message::timestamp *mutable_connect_time();

        inline ::message::timestamp *release_connect_time();

        inline void set_allocated_connect_time(::message::timestamp *connect_time);

        // @@protoc_insertion_point(class_scope:message.tcp_id)
    private:
        inline void set_has_ip();

        inline void clear_has_ip();

        inline void set_has_port();

        inline void clear_has_port();

        inline void set_has_pid();

        inline void clear_has_pid();

        inline void set_has_connect_time();

        inline void clear_has_connect_time();

        ::google::protobuf::UnknownFieldSet _unknown_fields_;

        ::google::protobuf::uint32 _has_bits_[1];
        mutable int _cached_size_;
        ::std::string *ip_;
        ::google::protobuf::int32 port_;
        ::google::protobuf::int32 pid_;
        ::message::timestamp *connect_time_;

        friend void protobuf_AddDesc_mes_2ebase_2eproto();

        friend void protobuf_AssignDesc_mes_2ebase_2eproto();

        friend void protobuf_ShutdownFile_mes_2ebase_2eproto();

        void InitAsDefaultInstance();

        static tcp_id *default_instance_;
    };
// ===================================================================


// ===================================================================

// timestamp

// required int64 seconds = 1;
    inline bool timestamp::has_seconds() const {
        return (_has_bits_[0] & 0x00000001u) != 0;
    }

    inline void timestamp::set_has_seconds() {
        _has_bits_[0] |= 0x00000001u;
    }

    inline void timestamp::clear_has_seconds() {
        _has_bits_[0] &= ~0x00000001u;
    }

    inline void timestamp::clear_seconds() {
        seconds_ = GOOGLE_LONGLONG(0);
        clear_has_seconds();
    }

    inline ::google::protobuf::int64 timestamp::seconds() const {
        // @@protoc_insertion_point(field_get:message.timestamp.seconds)
        return seconds_;
    }

    inline void timestamp::set_seconds(::google::protobuf::int64 value) {
        set_has_seconds();
        seconds_ = value;
        // @@protoc_insertion_point(field_set:message.timestamp.seconds)
    }

// optional int32 nanos = 2;
    inline bool timestamp::has_nanos() const {
        return (_has_bits_[0] & 0x00000002u) != 0;
    }

    inline void timestamp::set_has_nanos() {
        _has_bits_[0] |= 0x00000002u;
    }

    inline void timestamp::clear_has_nanos() {
        _has_bits_[0] &= ~0x00000002u;
    }

    inline void timestamp::clear_nanos() {
        nanos_ = 0;
        clear_has_nanos();
    }

    inline ::google::protobuf::int32 timestamp::nanos() const {
        // @@protoc_insertion_point(field_get:message.timestamp.nanos)
        return nanos_;
    }

    inline void timestamp::set_nanos(::google::protobuf::int32 value) {
        set_has_nanos();
        nanos_ = value;
        // @@protoc_insertion_point(field_set:message.timestamp.nanos)
    }

// -------------------------------------------------------------------

// tcp_id

// required string ip = 1;
    inline bool tcp_id::has_ip() const {
        return (_has_bits_[0] & 0x00000001u) != 0;
    }

    inline void tcp_id::set_has_ip() {
        _has_bits_[0] |= 0x00000001u;
    }

    inline void tcp_id::clear_has_ip() {
        _has_bits_[0] &= ~0x00000001u;
    }

    inline void tcp_id::clear_ip() {
        if (ip_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            ip_->clear();
        }
        clear_has_ip();
    }

    inline const ::std::string &tcp_id::ip() const {
        // @@protoc_insertion_point(field_get:message.tcp_id.ip)
        return *ip_;
    }

    inline void tcp_id::set_ip(const ::std::string &value) {
        set_has_ip();
        if (ip_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            ip_ = new ::std::string;
        }
        ip_->assign(value);
        // @@protoc_insertion_point(field_set:message.tcp_id.ip)
    }

    inline void tcp_id::set_ip(const char *value) {
        set_has_ip();
        if (ip_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            ip_ = new ::std::string;
        }
        ip_->assign(value);
        // @@protoc_insertion_point(field_set_char:message.tcp_id.ip)
    }

    inline void tcp_id::set_ip(const char *value, size_t size) {
        set_has_ip();
        if (ip_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            ip_ = new ::std::string;
        }
        ip_->assign(reinterpret_cast<const char *>(value), size);
        // @@protoc_insertion_point(field_set_pointer:message.tcp_id.ip)
    }

    inline ::std::string *tcp_id::mutable_ip() {
        set_has_ip();
        if (ip_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            ip_ = new ::std::string;
        }
        // @@protoc_insertion_point(field_mutable:message.tcp_id.ip)
        return ip_;
    }

    inline ::std::string *tcp_id::release_ip() {
        clear_has_ip();
        if (ip_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            return NULL;
        } else {
            ::std::string *temp = ip_;
            ip_ = const_cast< ::std::string *>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
            return temp;
        }
    }

    inline void tcp_id::set_allocated_ip(::std::string *ip) {
        if (ip_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
            delete ip_;
        }
        if (ip) {
            set_has_ip();
            ip_ = ip;
        } else {
            clear_has_ip();
            ip_ = const_cast< ::std::string *>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
        }
        // @@protoc_insertion_point(field_set_allocated:message.tcp_id.ip)
    }

// required int32 port = 2;
    inline bool tcp_id::has_port() const {
        return (_has_bits_[0] & 0x00000002u) != 0;
    }

    inline void tcp_id::set_has_port() {
        _has_bits_[0] |= 0x00000002u;
    }

    inline void tcp_id::clear_has_port() {
        _has_bits_[0] &= ~0x00000002u;
    }

    inline void tcp_id::clear_port() {
        port_ = 0;
        clear_has_port();
    }

    inline ::google::protobuf::int32 tcp_id::port() const {
        // @@protoc_insertion_point(field_get:message.tcp_id.port)
        return port_;
    }

    inline void tcp_id::set_port(::google::protobuf::int32 value) {
        set_has_port();
        port_ = value;
        // @@protoc_insertion_point(field_set:message.tcp_id.port)
    }

// required int32 pid = 3;
    inline bool tcp_id::has_pid() const {
        return (_has_bits_[0] & 0x00000004u) != 0;
    }

    inline void tcp_id::set_has_pid() {
        _has_bits_[0] |= 0x00000004u;
    }

    inline void tcp_id::clear_has_pid() {
        _has_bits_[0] &= ~0x00000004u;
    }

    inline void tcp_id::clear_pid() {
        pid_ = 0;
        clear_has_pid();
    }

    inline ::google::protobuf::int32 tcp_id::pid() const {
        // @@protoc_insertion_point(field_get:message.tcp_id.pid)
        return pid_;
    }

    inline void tcp_id::set_pid(::google::protobuf::int32 value) {
        set_has_pid();
        pid_ = value;
        // @@protoc_insertion_point(field_set:message.tcp_id.pid)
    }

// required .message.timestamp connect_time = 4;
    inline bool tcp_id::has_connect_time() const {
        return (_has_bits_[0] & 0x00000008u) != 0;
    }

    inline void tcp_id::set_has_connect_time() {
        _has_bits_[0] |= 0x00000008u;
    }

    inline void tcp_id::clear_has_connect_time() {
        _has_bits_[0] &= ~0x00000008u;
    }

    inline void tcp_id::clear_connect_time() {
        if (connect_time_ != NULL) connect_time_->::message::timestamp::Clear();
        clear_has_connect_time();
    }

    inline const ::message::timestamp &tcp_id::connect_time() const {
        // @@protoc_insertion_point(field_get:message.tcp_id.connect_time)
        return connect_time_ != NULL ? *connect_time_ : *default_instance_->connect_time_;
    }

    inline ::message::timestamp *tcp_id::mutable_connect_time() {
        set_has_connect_time();
        if (connect_time_ == NULL) connect_time_ = new ::message::timestamp;
        // @@protoc_insertion_point(field_mutable:message.tcp_id.connect_time)
        return connect_time_;
    }

    inline ::message::timestamp *tcp_id::release_connect_time() {
        clear_has_connect_time();
        ::message::timestamp *temp = connect_time_;
        connect_time_ = NULL;
        return temp;
    }

    inline void tcp_id::set_allocated_connect_time(::message::timestamp *connect_time) {
        delete connect_time_;
        connect_time_ = connect_time;
        if (connect_time) {
            set_has_connect_time();
        } else {
            clear_has_connect_time();
        }
        // @@protoc_insertion_point(field_set_allocated:message.tcp_id.connect_time)
    }


// @@protoc_insertion_point(namespace_scope)

}  // namespace message

#ifndef SWIG
namespace google {
    namespace protobuf {


    }  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_mes_2ebase_2eproto__INCLUDED
